#summary The framework features a powerful and flexible search functionality.

= Introduction =

The framework features a powerful and flexible search functionality. This is used by passing a search object to search methods on general and generic DAOs.

The search object provides flexible search options:
  * Filtering on properties using standard operators ( =, !=, >, <, >=, <=, LIKE, IN, IS NULL, IS EMPTY ).
  * Combining individual filters with any combination of logical operators ( AND, OR, NOT ).
  * Sorting on properties.
  * Paging.
  * Defining a search remotely from client code.
  * Transforming search results into objects, lists, arrays and maps
  * Specifying which associations to fetch eagerly.
  * Specifying column operators such as COUNT, SUM, AVG, MAX, etc.
  * All of the above work with nested properties (i.e. properties of related objects)

= Details =
*Javadocs*:
  * http://hibernate-generic-dao.googlecode.com/svn/trunk/source/doc/index.html?com/trg/dao/search/ISearch.html
  * http://hibernate-generic-dao.googlecode.com/svn/trunk/source/doc/index.html?com/trg/dao/search/IMutableSearch.html
  * http://hibernate-generic-dao.googlecode.com/svn/trunk/source/doc/index.html?com/trg/dao/search/ISearch.html

== Full API Reference ==

===General===
The framework's search functionality API takes an `ISearch`. This interface is meant
to be a read-only interface for a search object. The framework will not modify an `ISearch`. There is another interface, `IMutableSearch` which provides more methods for altering search parameters.

Anyone can provide their own implementation of the `ISearch` and/or `IMutableSearch` objects, but the framework includes a general one with lots of extra convenience methods for manipulating search parameters. This is the `Search` class. This `Search` class will probably be all you need for all your server-side operations. (Note: The framework also has an example of another `ISearch` implementation with the Flex search.)

===Filtering===
A search can have a collection of _filters_. By default there is an 'AND' condition between these; however, the _disjunction_ property can be set to TRUE, and an 'OR' condition will be used.

The following filtering operators are available:
|| *Operator* || *Explanation* || *Example* ||
|| EQUAL ||  || `Filter.equal("name", "Bob")` ||
|| NOT_EQUAL ||  || `Filter.notEqual("age", 5)` ||
|| GREATER_THAN ||  || `Filter.greaterThan("age", 5)` ||
|| GREATER_OR_EQUAL ||  || `Filter.greaterOrEqual("name", "M")` ||
|| LESS_THAN ||  || `Filter.lessThan("name", "N")` ||
|| LESS_OR_EQUAL ||  || `Filter.lessOrEqual("age", 65)` ||
|| IN || Equal to one of the items in the list of values. Value can be a collection or an array. || `Filter.in("eyeColor", EyeColor.BLUE, EyeColor.HAZEL)` ||
|| NOT_IN ||  || `Filter.notIn("hairColor", HairColor.BROWN, HairColor.BLACK)` ||
|| LIKE || Takes a SQL like expression || `Filter.like("name", "Wil%")` ||
|| ILIKE || LIKE + ignore case (Note: Some databases ignore case by default) || `Filter.ilike("name", "wiL%")` ||
|| NULL || SQL IS NULL || `Filter.isNull("primaryDoctor")` ||
|| NOT_NULL ||  || `Filter.isNotNull("phone")` ||
|| EMPTY || NULL or empty string or empty collection/assocation || `Filter.isEmpty("children")` ||
|| NOT_EMPTY ||  || `Filter.isNotEmpty("primaryDoctor.firstName")` ||
|| SOME || Applies to collection/association properties. Takes another `Filter` as a value, and matches when at least one of the values in the collection matches the filter. || `Filter.some("children", Filter.equal("name", "Joey")) //has a child named 'Joey'` ||
|| ALL || Same as SOME, except that all values must match the filter. || `Filter.all("children", Filter.greaterOrEqual("age", 18)) //all children are 18 or older` ||
|| NONE || Same as SOME, except that none of the values may match the filter. || `Filter.none("pets", Filter.and(Filter.equal("species", "cat"), Filter.lessThan("age", .75)) //has no cats under 9 months old` ||
|| AND || Takes no property. Takes an array or collection of `Filter`s as a value. Matches when all the filters in the value match. || `Filter.and(Filter.greaterOrEqual("age",40), Filter.lessThan("age", 65))` ||
|| OR || Same as AND, except that it matches when any of the filters match. || `Filter.or(Filter.like("firstName","Wil%"), Filter.like("lastName","Wil%"))` ||
|| NOT || Takes no property. Takes a single `Filter` as a value. Matches when the filter in the value does not match. || `Filter.not(Filter.ilike("name", "W%")) //name does not start with 'w'` ||

===Selecting and Transforming Results===
By default, the results of a search will be a list of the entity objects that were searched on. However, as with Hibernate queries, it is possible to get different information back in each row.

*Fields*

A search can have a collection of _fields_. These are analogous to the "SELECT" clause in SQL or HQL. Each field corresponds to a property value or a column operator applied to a property. Each field may also be assigned a key string. This will be used instead of the property name as a map key when using the MAP result mode. If no fields are specified, the entity itself is used as the single result for each record.

Here are the available field operators:
  * PROPERTY (i.e. no operator)
  * COUNT
  * COUNT_DISTINCT
  * MAX
  * MIN
  * SUM
  * AVG

*Result Modes*

The following result modes are available for a search:
|| AUTO || The result mode is automatically determined according to the following rules: If any field is specified with a key, use MAP mode. Otherwise, if zero or one fields are specified, use SINGLE mode. Otherwise, use ARRAY mode. ||
|| ARRAY || returns each result as an Object array (`Object[]`) with the entries corresponding to the fields added to the search. ||
|| LIST || returns each result as a list of Objects (`List<Object>`). ||
|| MAP || returns each row as a map with properties' names or keys for keys to the corresponding values. ||
|| SINGLE || Exactly one field or no fields must be specified to use this result mode. The result list contains just the value of that property for each element or the entity if no fields are specified. ||

===Sorting===
A search can have a collection of _sorts_. These sorts are applied in order, just as in the SQL "ORDER BY" clause. Each sort specifies a property and a direction (asc or desc). There is also a flag for whether or not to ignore case. (Note: Some databases ignore case by default.)

===Paging===

===Controlling Association Fetching===

== Usage examples ==
{{{
Search search = new Search(Project.class);

search.addFilterEqual("name", "hibernate-generic-dao");

search.addFilterLessThan("completionDate", new Date());

search.addFilterOr(
		Filter.equal("name", "Jack"),
		Filter.and(
				Filter.equal("name", "Jill"),
				Filter.like("location", "%Chicago%"),
				Filter.greaterThan("age", 5)
		)
);

search.addFilterIn("name", "Jack", "Jill", "Bob");

search.addFilterNot(Filter.in("name","Jack", "Jill", "Bob"));


search.addSort("name");
search.addSort("age", true); //descending

//paging
search.setMaxResults(15);
search.setPage(3);
}}}

Nested properties are also fully supported...
{{{
search.addFilterEqual("status.name", "active");
search.addFilterGreaterThan("workgroup.manager.salary", 75000.00);

search.addSort("status.name");
}}}

Calling a search:
{{{
Search search = new Search();
search.addFilterGreaterThan("userCount", 500);
search.setMaxResults(15);

//get one page of results
List<Project> results = projectDAO.search(search);

//get the total number of results (ignores paging)
int totalResults = projectDAO.searchLength(search);

//get one page of results and the total number of results without paging
SearchResult<Project> result = projectDAO.searchAndLength(search);
results = result.results;
totalResults = results.totalLength;

//get the average userCount for project matching the filter criteria
search.setFetchMode(Search.FETCH_SINGLE)
search.addFetch("userCount", Fetch.OP_AVG);
int avgCount = (int) projectDAO.uniqueResult(search);
}}}